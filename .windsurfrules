# Windsurf IDE Rules - XM Cloud Front End Starter Kits

## Project Overview

### Repository Structure
This is the **XM Cloud Front End Application Starter Kits** repository containing multiple Next.js starter applications and SPA examples for Sitecore XM Cloud development.

**Key Directories:**
- `/examples/` - Starter front-end applications (Next.js and SPA)
  - `basic-nextjs` - Simple Next.js starter with basic XM Cloud integration
  - `kit-nextjs-article-starter` - **Solterra & Co.** - Editorial-style template for lifestyle brands
  - `kit-nextjs-location-finder` - **Alaris** - Car brand template with location finder functionality
  - `kit-nextjs-product-listing` - **SYNC** - Product-focused template for audio gear companies
  - `kit-nextjs-skate-park` - Demo site showcasing component examples
  - `basic-spa` - SPA starter kit with Angular and Node proxy
- `/authoring/` - Sitecore content items, templates, and deployment configurations
- `/local-containers/` - Docker setup for local development environments
- `xmcloud.build.json` - Primary configuration for XM Cloud deployment

### Technology Stack

**Core Technologies:**
- **Next.js 14+** - React framework with App Router and Pages Router support
- **TypeScript** - Strict type safety throughout all components
- **Sitecore XM Cloud** - Headless content management and delivery
- **Sitecore Content SDK** (`@sitecore-content-sdk/nextjs`) - Modern SDK for XM Cloud integration
- **Tailwind CSS** - Utility-first CSS with container queries (@container)
- **Shadcn/ui** - Modern component library with accessibility features

**Additional Libraries:**
- **Framer Motion** - Animation library for interactive components
- **Lucide React** - Icon library for consistent iconography
- **next-localization** - Internationalization with dictionary support
- **change-case** - String case transformation utilities

**Development Tools:**
- **Docker** - Containerized local development with Sitecore CM
- **Node.js LTS** - JavaScript runtime environment
- **npm** - Package management across all starter applications

### Architecture Principles

**Multi-Starter Architecture:**
- Each example is a standalone application with independent deployment
- Shared patterns and conventions across all starters (no monorepo linking)
- Common XM Cloud integration patterns
- Content-first development with field-driven rendering

**Development Workflow:**
- Each starter maintains its own `src/` directory structure
- Shared utilities should be copied, not shared
- Configuration files specific to each starter application
- Independent package.json for each example

**DMZ git flow (planned for future):**

DMZ git flow will be implemented in the future to support better development practices, scaling, efficiency and developer productivity. Below is an outline of the planned workflow and processes that will be followed:

- Has a shared main repo (`upstream repository`) with two key branches: `main` and `dmz`
- Each contributor uses their own fork as their workspace
- Feature branches are sourced from `main` but Pull Requests (PRs) with changes are merged to `dmz` branch
- `main` branch in the `upstream repository` is always clean (deployable, branchable and reliable). It does not accept PRs created by developers.
- Developers should push changes to feature branches in their own fork and then create PRs to `dmz` branch in the `upstream repository`.
- PRs are merged by reviewers to the `dmz` branch after review and validation. Conflicts should be resolved by rebasing onto main.
- Once a PR has been merged into `dmz` branch the code changes are validated through an automated full build of the `dmz` branch `HEAD` in the Continuous Integration server.
- The `dmz` branch acts as a staging/integration branch and once several changes are integrated and tested in the `dmz` branch they can be manually merged to the `main` branch using merge commits (usually at the end of 1 or 2 weeks)
- If the build fails, the changes are or issues are found in the `dmz` branch during integration, the problematic commits can be reverted

---

## Coding Standards

### TypeScript Configuration

**Strict Mode Requirements:**
- Enable strict mode in all projects
- Prefer explicit types over `any`
- Use discriminated unions for complex state
- Export types at module boundaries for reusability
- Define proper interfaces for XM Cloud data structures

**Type Usage:**
- Use `type` imports for TypeScript types: `import type React from 'react'`
- Prefer type assertions over any: `value as LayoutData`
- Use discriminated unions for complex state management
- Define interfaces for all component props and XM Cloud data structures

### Naming Conventions

**Variables and Functions:**
- Use camelCase: `handleClick()`, `isActive`, `prefersReducedMotion`
- Boolean variables: prefix with `is`, `has`, `can`, `should`
- Event handlers: prefix with `handle` or `on`: `handleClick`, `handleKeyDown`
- State variables: descriptive names like `activeIndex`, `isExpanding`

**Components (React):**
- Use PascalCase: `ArticleHeader`, `ProductListing`, `VerticalImageAccordion`
- Main component files: `Hero.tsx`, `ProductListing.tsx`
- Component directories: kebab-case like `article-header/`, `product-listing/`

**Constants and Environment Variables:**
- Use UPPER_SNAKE_CASE: `USER_ZIPCODE`, `DEFAULT_TIMEOUT`
- Environment variables: `SITECORE_EDGE_CONTEXT_ID`, `NEXT_PUBLIC_DEFAULT_SITE_NAME`
- Dictionary keys: `dictionaryKeys.HERO_SubmitCTALabel`

**Types and Interfaces:**
- Component props: `HeroProps`, `ArticleHeaderProps`, `ProductListingProps`
- Field interfaces: `ArticleHeaderFields`, `HeroFields`
- Parameter interfaces: `ArticleHeaderParams`, `VerticalImageAccordionParams`
- Use `{ [key: string]: any; // eslint-disable-line }` for flexible params

### File Naming Patterns

- Utilities: `NoDataFallback.tsx`, `date-utils.ts`
- Main components: `ComponentName.tsx`

### Import Organization

**Import Patterns:**
- Use `type` imports for TypeScript types: `import type React from 'react'`
- Import Sitecore components: `import { Text, RichText, Image, useSitecore } from '@sitecore-content-sdk/nextjs'`
- Import utilities: `import { cn } from '@/lib/utils'`
- Import UI components: `import { Button } from '@/components/ui/button'`
- Import as alias for reusable components: `import { Default as ImageWrapper } from '@/components/image/ImageWrapper.dev'`

```typescript
// Standard import pattern for XM Cloud components
'use client'; // When client-side features needed

import type React from 'react';
import { useState, useEffect, useRef } from 'react';
import { cn } from '@/lib/utils';
import { Text, RichText, Image, useSitecore } from '@sitecore-content-sdk/nextjs';
import { ComponentProps } from '@/lib/component-props';
import { NoDataFallback } from '@/utils/NoDataFallback';
import { Default as ImageWrapper } from '@/components/image/ImageWrapper.dev';
import { ButtonBase } from '@/components/button-component/ButtonComponent';
```

### Documentation Standards

**JSDoc Comments:**
- All new functions, interfaces, classes must have JSDoc style comments
- Include @param tags for all parameters with types and descriptions
- Include @returns tag for return values with type and description
- Use descriptive comments that explain the purpose and behavior

```typescript
/**
 * Hero component for displaying prominent content on XM Cloud pages
 * @param {HeroProps} props - Component props from XM Cloud datasource
 * @returns {JSX.Element} The rendered hero component with variants support
 */
export const HeroDefault: React.FC<HeroProps> = (props) => {
  const { fields, isPageEditing } = props;
  
  if (!fields?.data?.datasource) {
    return <NoDataFallback componentName="Hero" />;
  }
  
  // Component implementation
};
```

---

## Folder Structure

### Standard Directory Layout

```
examples/[starter-name]/
├── src/
│   ├── components/          # React components organized by feature
│   │   ├── hero/           # Component directories with variants
│   │   │   └── Hero.tsx    # Main component file with props and all variants
│   │   ├── article-header/ # Component with complex structure
│   │   ├── product-listing/ # Multi-variant component
│   │   ├── ui/             # Shadcn/ui components (button, card, etc.)
│   │   ├── image/          # Reusable image wrapper
│   │   └── button-component/ # Button variations
│   ├── lib/                # Configuration and utilities
│   │   ├── component-props/ # Shared component props
│   │   ├── constants.ts    # Application constants
│   │   └── utils.ts        # Common utilities (cn helper)
│   ├── utils/              # Helper functions and utilities
│   │   ├── NoDataFallback.tsx # Standard fallback component
│   │   └── date-utils.ts   # Date formatting utilities
│   ├── hooks/              # Custom React hooks
│   ├── variables/          # Constants and dictionary keys
│   ├── pages/              # Next.js pages (Pages Router)
│   │   ├── api/           # API routes
│   │   └── [...path].tsx  # Catch-all route for XM Cloud
│   ├── app/                # Next.js App Router (if using)
│   ├── styles/             # Styling files (global CSS)
│   └── middleware.ts       # Next.js middleware
├── public/                 # Static assets
├── .env.local             # Local environment variables
├── .env.remote.example    # Environment template
├── next.config.js         # Next.js configuration
├── tailwind.config.ts     # Tailwind CSS configuration
├── tsconfig.json          # TypeScript configuration
└── package.json           # Dependencies and scripts
```

### File Organization Rules

**Component Files:**
- Main component file should contain all variants and props following the Locality of Behavior pattern
- Using `.dev.tsx` files for variant implementations is discouraged unless maintainability becomes dificult for the componenent and seperation can not be avoided
- Component directories use kebab-case naming
- Main component files use PascalCase naming

**Shared Utilities:**
- Place in dedicated directories (`lib/`, `utils/`, `hooks/`)
- Group UI components in `ui/` subdirectory
- Keep utilities focused and single-purpose

---

## Code Style and Best Practices

### Vibe-Coding Principles

**Core Philosophy:**
- Write clean, modular, and idiomatic code
- Prefer declarative over imperative patterns
- Make code readable and self-documenting
- TypeScript-first development approach
- Component-driven architecture with XM Cloud integration

**Code Organization:**
- Use modern JavaScript/TypeScript features
- Export public types at module boundaries
- Prefer pure functions and thin wrappers
- No top-level side effects (except page entry points)
- Modular architecture with clear separation of concerns

### Code Quality Standards

**Functional Programming:**
- Prefer pure functions where possible
- Use immutable data patterns
- Avoid side effects in business logic
- Compose small, focused functions
- Use React hooks appropriately

**Readability:**
- Use descriptive variable and function names
- Keep functions small and focused (single responsibility)
- Add JSDoc comments for complex business logic
- Prefer self-documenting code over extensive comments
- Use consistent naming patterns across all starters

### React Component Development

**React Best Practices:**
- Use functional components with hooks
- Implement proper prop validation with TypeScript
- Handle loading and error states explicitly
- Use React.memo for performance optimization when needed
- Follow React 18+ patterns and concurrent features

**XM Cloud Component Patterns:**
- Always validate field existence before rendering
- Provide meaningful fallbacks for missing content
- Use Sitecore field components for proper rendering
- Handle both editing and preview modes
- Implement proper error boundaries
- Handle destructuring, undefined errors and null values in datasource and field values gracefully

```typescript
// Good component pattern
import { Text, Image, useSitecore } from '@sitecore-content-sdk/nextjs';

interface HeroProps {
  fields: {
    data?: {
      datasource?: {
        title?: { jsonValue?: Field };
        subtitle?: { jsonValue?: Field };
        backgroundImage?: { jsonValue?: Field };
      };
    };
  };
}

export default function Hero({ fields }: HeroProps) {
  const { page } = useSitecore();
  const { isEditing } = page.mode;

  if (!fields) {
    return <div>Hero content not configured</div>;
  }

  // Handle destructuring errors with safe fallbacks
  const { data } = fields || {};
  const { datasource } = data || {};
  const { title, subtitle, backgroundImage } = datasource || {};

  return (
    <section className="hero">
      {/* Show field components in editing mode even if no content */}
      {(title?.jsonValue?.value || isEditing) && <Text field={title?.jsonValue} tag="h1" />}
      {(subtitle?.jsonValue?.value || isEditing) && <Text field={subtitle?.jsonValue} tag="p" />}
      {(backgroundImage?.jsonValue?.value?.src || isEditing) && (
        <Image field={backgroundImage?.jsonValue} />
      )}
    </section>
  );
}
```

### Safe Destructuring Examples

```typescript
// ✅ Safe destructuring with fallbacks
const { titleRequired, descriptionOptional } = fields || {};

// ✅ Safe nested destructuring
const { data: { datasource } = {} } = fields || {};

// ✅ Safe field access with optional chaining
field={fields.data?.datasource?.title?.jsonValue}

// ❌ Unsafe - can throw destructuring errors
const { title } = fields.data.datasource; // Error if fields.data is null

// ❌ Unsafe - can throw undefined errors  
field={fields.data.datasource.title.jsonValue} // Error if any part is null/undefined
```

### Error Handling

**Error Strategy:**
- Fail fast with clear, actionable messages
- Provide context in error messages
- Use custom error classes for domain-specific errors
- Handle edge cases explicitly with guard clauses
- Log errors appropriately for debugging

```typescript
async function fetchLayoutData(path: string): Promise<LayoutData> {
  if (!path) {
    throw new Error('Path is required for layout data fetch');
  }
  
  try {
    const response = await sitecoreLayoutService.getRouteData(path);
    return response.sitecore.route;
  } catch (error) {
    throw new XMCloudFetchError(`Failed to fetch layout data for path: ${path}`, error);
  }
}
```

**XM Cloud Error Patterns:**
- Handle missing datasource gracefully
- Provide fallback content for failed API calls
- Implement proper error boundaries for component failures
- Handle both connected and disconnected mode errors

### Security

**Input Validation:**
- Sanitize user inputs before processing
- Validate data at application boundaries
- Use type guards for runtime type checking
- Escape content when rendering to prevent XSS

**Environment Variables:**
- Never hardcode sensitive values in source code
- Use environment variables for all configuration
- Validate environment variables at application startup
- Use different .env files for different environments

```typescript
// Environment validation example
const requiredEnvVars = [
  'SITECORE_EDGE_CONTEXT_ID',
  'NEXT_PUBLIC_DEFAULT_SITE_NAME',
  'SITECORE_EDITING_SECRET'
];

requiredEnvVars.forEach(envVar => {
  if (!process.env[envVar]) {
    throw new Error(`Missing required environment variable: ${envVar}`);
  }
});
```

### Performance

**Optimization Patterns:**
- Cache XM Cloud API responses using React Query or similar caching solutions
- Use React.memo for expensive components
- Lazy-load non-critical modules: `const Component = lazy(() => import('./Component'))`
- Use useCallback and useMemo for expensive operations
- Implement proper loading states for data fetching

**Next.js Specific:**
- Use Next.js Image component for optimized images
- Implement proper ISR (Incremental Static Regeneration) patterns
- Use dynamic imports for code splitting
- Optimize bundle size with proper imports

---

## XM Cloud Component Development

### Component Architecture - Locality of Behavior Pattern

**Component Structure:**
- Create a single `ComponentName.tsx` with all variants and props
- Export named variants: `Default`, `ThreeUp`, `Slider`, `ImageBottom`, etc.
- Extend from `ComponentProps` from `@/lib/component-props`
- Use specific interface for component parameters
- Structure fields with `data.datasource` pattern
- Include `isPageEditing` prop for variants

```typescript
import type React from 'react';
import { useSitecore } from '@sitecore-content-sdk/nextjs';
import { ComponentProps } from '@/lib/component-props';
import { Field, ImageField } from '@sitecore-jss/sitecore-jss-nextjs';

interface HeroParams {
  [key: string]: any; // eslint-disable-line
}

interface HeroFields {
  title?: { jsonValue: Field<string> };
  subtitle?: { jsonValue: Field<string> };
  backgroundImage?: { jsonValue: ImageField };
}

interface HeroProps extends ComponentProps {
  params: HeroParams;
  fields: {
    data: {
      datasource: HeroFields;
    };
  };
  isPageEditing?: boolean;
}

export const Default: React.FC<HeroProps> = (props) => {
  const { page } = useSitecore();
  const { isEditing } = page.mode;
  return <HeroDefault {...props} isPageEditing={isEditing} />;
};

export const ImageBottom: React.FC<HeroProps> = (props) => {
  const { page } = useSitecore();
  const { isEditing } = page.mode;
  return <HeroImageBottom {...props} isPageEditing={isEditing} />;
};
```

### Data Source Validation

**Standard Validation Pattern:**
- Always check `fields?.data?.datasource` existence
- Use `NoDataFallback` component for missing datasources
- Handle both editing and preview modes
- Provide meaningful error messages

```typescript
import { NoDataFallback } from '@/utils/NoDataFallback';

export const HeroDefault: React.FC<HeroProps> = (props) => {
  const { fields, isPageEditing } = props;
  
  if (!fields?.data?.datasource) {
    return <NoDataFallback componentName="Hero" />;
  }
  
  const { title, description, image } = fields.data.datasource;
  
  // Component implementation
};
```

### Field Handling Patterns

**Sitecore Field Components:**
- Use `@sitecore-content-sdk/nextjs` field components
- Access field values through `jsonValue` property
- Handle optional fields with conditional rendering
- Use proper semantic HTML tags

```typescript
import { Text, RichText, Image } from '@sitecore-content-sdk/nextjs';

// Field rendering patterns
{title?.jsonValue && (
  <Text
    tag="h1"
    field={title.jsonValue}
    className="hero-title text-4xl font-bold"
  />
)}

{description?.jsonValue && (
  <RichText field={description.jsonValue} />
)}

{image?.jsonValue && (
  <Image
    field={image.jsonValue}
    alt={title?.jsonValue?.value || 'Hero image'}
    className="w-full h-auto"
  />
)}
```

### Editing Mode Handling

**Page Editing Support:**
- Use `useSitecore` hook to access page mode
- Check `page.mode.isEditing` for editing state
- Pass `isPageEditing` prop to variant components
- Provide different rendering for editing vs. preview

```typescript
import { useSitecore } from '@sitecore-content-sdk/nextjs';

export const Default: React.FC<ComponentProps> = (props) => {
  const { page } = useSitecore();
  const { isEditing } = page.mode;
  const isEditMode = props.isPageEditing || isEditing;
  
  if (isEditMode) {
    // Simplified rendering for editing mode
  }
  
  // Normal rendering
};
```

### Content SDK Import Guidelines

**Client-Safe Imports (Components & Client Code):**

```typescript
// ✅ SAFE - Client-side component usage
import { 
  Text, 
  RichText, 
  Image, 
  Link,
  Field, 
  LinkField, 
  ImageField,
  useSitecore,
  SitecoreProvider,
  Placeholder 
} from '@sitecore-content-sdk/nextjs';

// ✅ SAFE - Middleware usage (edge runtime)
import { 
  LocalizationMiddleware,
  RedirectsMiddleware 
} from '@sitecore-content-sdk/nextjs/middleware';
```

**Server-Only Imports (Configuration & Build):**

```typescript
// ❌ NEVER in client components
// ✅ ONLY in server-side contexts (sitecore.config.ts, sitecore.cli.config.ts)
import { defineConfig } from '@sitecore-content-sdk/nextjs/config';
import { defineCliConfig } from '@sitecore-content-sdk/nextjs/config-cli';
import { generateSites, generateMetadata, extractFiles } from '@sitecore-content-sdk/nextjs/tools';

// ✅ ONLY in lib/sitecore-client.ts or server utilities
import { SitecoreClient, GraphQLRequestClient } from '@sitecore-content-sdk/nextjs/client';
```

**API Route Imports (Next.js API routes):**

```typescript
// ✅ SAFE - API routes only (/pages/api/ or /app/api/)
import { SitemapMiddleware, RobotsMiddleware } from '@sitecore-content-sdk/nextjs/middleware';
import { HealthcheckMiddleware } from '@sitecore-content-sdk/nextjs/monitoring';
import { 
  EditingRenderMiddleware, 
  EditingConfigMiddleware, 
  FEAASRenderMiddleware,
  isDesignLibraryPreviewData 
} from '@sitecore-content-sdk/nextjs/editing';

// ✅ SAFE - Utility functions for page routes
import { extractPath, handleEditorFastRefresh } from '@sitecore-content-sdk/nextjs/utils';
```

**Import Context Rules:**
- **Configuration Files**: `sitecore.config.ts` uses `/config`, `sitecore.cli.config.ts` uses `/config-cli` and `/tools`
- **Component Files**: React components use main package only
- **Server Utilities**: `lib/sitecore-client.ts` uses `/client` submodule
- **Page Files**: Page components use main package + `/utils` for path utilities
- **API Routes**: Use `/middleware`, `/editing`, `/monitoring` as needed

```typescript
// Example: Component file structure
// ✅ CORRECT
import { Text, useSitecore } from '@sitecore-content-sdk/nextjs';

// ❌ WRONG - will cause build errors
import { defineConfig } from '@sitecore-content-sdk/nextjs/config';
import { SitecoreClient } from '@sitecore-content-sdk/nextjs/client';
```

### Utility Integration

**Common Utilities:**
- Use `NoDataFallback` for missing datasources
- Import image wrapper: `Default as ImageWrapper` from `@/components/image/ImageWrapper.dev`
- Use button components: `ButtonBase` from `@/components/button-component/ButtonComponent`
- Implement localization with `useI18n` and `dictionaryKeys`

```typescript
import { NoDataFallback } from '@/utils/NoDataFallback';
import { Default as ImageWrapper } from '@/components/image/ImageWrapper.dev';
import { ButtonBase } from '@/components/button-component/ButtonComponent';
import { useI18n } from 'next-localization';
import { dictionaryKeys } from '@/variables/dictionary';
```

### Accessibility and Performance

**Client-Side Interactivity:**
- Use `'use client'` directive for client-side interactivity
- Implement proper ARIA attributes for interactive components
- Use React hooks like `useState`, `useEffect`, `useRef` appropriately
- Check for `prefers-reduced-motion` when using animations

```typescript
'use client';

import { useState, useEffect, useRef } from 'react';

export const InteractiveComponent: React.FC<Props> = (props) => {
  const [activeIndex, setActiveIndex] = useState<number>(0);
  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);
  
  useEffect(() => {
    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
    setPrefersReducedMotion(mediaQuery.matches);
  }, []);
  
  // Component implementation
};
```

---

## Styling

### Tailwind CSS and Shadcn/ui

**Utility-First CSS:**
- Use Tailwind CSS utility classes throughout
- Import UI components from `@/components/ui/`
- Use `cn()` utility for conditional classes
- Follow container query patterns with `@container` classes

```typescript
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';

<div className={cn(
  '@container bg-primary rounded-default',
  'relative mx-auto my-6 max-w-7xl px-4 py-16',
  isActive && '@md:w-full'
)}>
```

---

## Next.js Development Patterns

### Configuration

**Next.js Config:**
- Configure i18n for multi-language XM Cloud sites
- Set up proper image domains for XM Cloud media
- Implement rewrites for XM Cloud API routes
- Configure webpack for SCSS and other assets
- Set up proper build optimization

```javascript
// next.config.js pattern
const nextConfig = {
  i18n: {
    locales: ['en', 'en-CA'],
    defaultLocale: process.env.DEFAULT_LANGUAGE || 'en',
  },
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'edge*.**',
      },
      {
        protocol: 'https',
        hostname: 'xmc-*.**',
      },
    ],
  },
  async rewrites() {
    return [
      {
        source: '/robots.txt',
        destination: '/api/robots',
      },
      {
        source: '/sitemap.xml',
        destination: '/api/sitemap',
      },
    ];
  },
};
```

**Environment Variables:**
- Use NEXT_PUBLIC_ prefix for client-side variables
- Validate required environment variables at build time
- Use different .env files for different environments
- Never commit sensitive environment variables

### Pages and Routing

**Catch-All Routes:**
- Use `[...path].tsx` for XM Cloud page routing
- Handle both single and multi-segment paths
- Implement proper 404 handling for non-existent items
- Support preview mode for content authors

```typescript
// [...path].tsx pattern
export async function getServerSideProps(context: GetServerSidePropsContext) {
  const path = Array.isArray(context.params?.path) 
    ? context.params.path.join('/')
    : context.params?.path || '/';
    
  const locale = context.locale || 'en';
  
  try {
    const layoutData = await layoutService.getRouteData(path, locale);
    
    if (!layoutData.sitecore.route) {
      return { notFound: true };
    }
    
    return { 
      props: { 
        layoutData,
        notFound: false 
      } 
    };
  } catch (error) {
    console.error(`Error fetching route data for ${path}:`, error);
    return { notFound: true };
  }
}
```

**Static Generation:**
- Use ISR (Incremental Static Regeneration) for XM Cloud content
- Implement proper revalidation strategies
- Handle dynamic paths with getStaticPaths
- Consider build time vs. runtime performance trade-offs

### API Routes

**XM Cloud Integration:**
- Create API routes for XM Cloud services
- Handle authentication and authorization properly
- Implement proper error handling and logging
- Cache responses when appropriate

```typescript
// api/robots.ts pattern
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const robotsContent = await robotsService.getRobots();
    
    res.setHeader('Content-Type', 'text/plain');
    res.status(200).send(robotsContent);
  } catch (error) {
    console.error('Error generating robots.txt:', error);
    res.status(500).send('Error generating robots.txt');
  }
}
```

### Middleware

**XM Cloud Editing:**
- Handle editing mode detection
- Implement proper cookie handling for XM Cloud
- Set up redirects for content authors
- Support preview mode functionality

```typescript
// middleware.ts pattern
export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  
  // Handle XM Cloud editing mode
  if (request.cookies.get('sc_mode')?.value === 'edit') {
    // Redirect to editing host
    const editingUrl = new URL(pathname, process.env.EDITING_HOST_URL);
    return NextResponse.redirect(editingUrl);
  }
  
  return NextResponse.next();
}
```

### Performance Optimization

**Image Optimization:**
- Always use NextImage component from ContentSDK for XM Cloud media as it supports inline editing in editor mode and uses Image component from next internally
- Configure proper image domains and sizes
- Implement lazy loading for below-fold images
- Use proper alt text from XM Cloud fields

**Code Splitting:**
- Use dynamic imports for large components
- Implement route-based code splitting
- Lazy load non-critical functionality
- Optimize bundle size with proper imports

**Caching:**
- Implement proper caching headers for XM Cloud content
- Use ISR for frequently updated content
- Cache API responses appropriately
- Consider CDN caching strategies

### App Router (Next.js 13+)

**Server Components:**
- Use Server Components for XM Cloud data fetching
- Implement proper loading and error handling
- Handle streaming for better user experience
- Use Client Components only when necessary

**Layout Files:**
- Create proper layout hierarchy
- Handle XM Cloud navigation and footer
- Implement proper SEO meta tags
- Support multi-language layouts

### Deployment

**Build Optimization:**
- Optimize for XM Cloud deployment environment
- Handle environment-specific configurations
- Implement proper health checks
- Monitor build performance and size

**XM Cloud Integration:**
- Configure proper rendering host settings
- Handle XM Cloud deployment pipelines
- Implement proper monitoring and logging
- Support blue-green deployment patterns

---

## Testing

### Testing Strategy

**Component Testing:**
- Test component rendering with various XM Cloud field configurations
- Mock XM Cloud services and API calls
- Test error scenarios (missing fields, API failures)
- Verify proper handling of editing vs. preview modes
- Test responsive behavior and accessibility

**Integration Testing:**
- Test complete page rendering with XM Cloud data
- Verify API route functionality
- Test middleware behavior for XM Cloud integration
- Validate environment variable handling
- Test deployment and build processes

### Testing Tools

**Recommended Stack:**
- **Jest** or **Vitest** for unit testing
- **React Testing Library** for component testing
- **MSW (Mock Service Worker)** for API mocking
- **Playwright** or **Cypress** for E2E testing
- **Storybook** for component documentation and testing

**XM Cloud Mocking:**
- Create mock data that matches XM Cloud field structures
- Mock layout service responses
- Simulate both connected and disconnected modes
- Test with various content scenarios

```typescript
// Mock XM Cloud field data
const mockHeroFields = {
  title: { value: 'Test Hero Title', editable: false },
  subtitle: { value: 'Test Hero Subtitle', editable: false },
  backgroundImage: {
    value: {
      src: '/test-image.jpg',
      alt: 'Test Image',
      width: 1200,
      height: 600,
    },
    editable: false,
  },
};
```

### Component Testing Patterns

**Field Validation Testing:**
- Test components with missing fields
- Test components with empty field values
- Test components with various field types
- Verify proper fallback rendering

```typescript
// Component test example
describe('Hero Component', () => {
  it('renders with all fields present', () => {
    render(<Hero fields={mockHeroFields} />);
    
    expect(screen.getByText('Test Hero Title')).toBeInTheDocument();
    expect(screen.getByText('Test Hero Subtitle')).toBeInTheDocument();
    expect(screen.getByRole('img')).toHaveAttribute('alt', 'Test Image');
  });
  
  it('handles missing fields gracefully', () => {
    render(<Hero fields={{}} />);
    
    expect(screen.getByText(/content not configured/i)).toBeInTheDocument();
  });
});
```

### API Testing

**XM Cloud API Mocking:**
- Mock layout service responses
- Test error handling for API failures
- Verify proper caching behavior
- Test authentication and authorization

```typescript
// API route test example
import { createMocks } from 'node-mocks-http';
import handler from '../pages/api/robots';

describe('/api/robots', () => {
  it('returns robots.txt content', async () => {
    const { req, res } = createMocks({
      method: 'GET',
    });
    
    await handler(req, res);
    
    expect(res._getStatusCode()).toBe(200);
    expect(res._getHeaders()['content-type']).toBe('text/plain');
  });
});
```

### E2E Testing

**Page Testing:**
- Test complete user journeys
- Verify XM Cloud content rendering
- Test navigation and routing
- Validate responsive design
- Test accessibility compliance

**Performance Testing:**
- Test page load times
- Verify image optimization
- Test bundle size impact
- Monitor Core Web Vitals

```typescript
// Playwright E2E test example
test('homepage loads and displays content', async ({ page }) => {
  await page.goto('/');
  
  // Wait for XM Cloud content to load
  await page.waitForSelector('[data-testid="hero-component"]');
  
  // Verify content is displayed
  await expect(page.locator('h1')).toBeVisible();
  await expect(page.locator('nav')).toBeVisible();
});
```

### Test Data Management

**XM Cloud Test Data:**
- Create realistic test data that matches XM Cloud structures
- Use factories for generating test data
- Maintain test data consistency across tests
- Update test data when XM Cloud schemas change

```typescript
// Test data factory
export const createMockLayoutData = (overrides = {}) => ({
  sitecore: {
    context: {
      pageEditing: false,
      language: 'en',
      site: { name: 'test-site' },
    },
    route: {
      name: 'Test Page',
      displayName: 'Test Page',
      fields: {},
      placeholders: {},
      ...overrides,
    },
  },
});
```

### Testing Commands

**Package Scripts:**
- `npm test` - Run unit tests
- `npm run test:watch` - Run tests in watch mode
- `npm run test:coverage` - Run tests with coverage report
- `npm run test:e2e` - Run end-to-end tests
- `npm run test:ci` - Run all tests in CI mode

### Coverage Requirements

**Quality Standards:**
- Tests should be comprehensive enough to cover business logic and to validate that sites and componenets are working as intended
- Ensure different rendering options and scenarios are considered such as Design Library, Page Editor, Preview mode, Hosted Vercel Sites and Local Deployments
- Test error scenarios and edge cases
- Maintain test quality over quantity

### Continuous Integration

**CI/CD Testing:**
- Run all tests on pull requests
- Generate coverage reports
- Test against multiple Node.js versions
- Validate build processes
- Check for accessibility violations

**Quality Gates:**
- All tests must pass before merging
- Coverage thresholds must be met
- No linting errors allowed
- Performance budgets must be maintained
- Security scans must pass

---

## Universal Coding Principles

### DRY Principle

- Don't Repeat Yourself - extract common functionality
- Create reusable utilities and helper functions
- Use composition over inheritance
- Share types and interfaces across components

### SOLID Principles

- Single Responsibility: each function/component has one purpose
- Open/Closed: extend functionality through composition
- Dependency Inversion: depend on abstractions, not implementations

### Code Clarity

- Write self-documenting code with clear intent
- Use meaningful names that express business concepts
- Prefer explicit over implicit behavior
- Make dependencies and requirements obvious

### Modular Design

- Organize code into focused, cohesive components
- Minimize coupling between modules
- Use clear interfaces between layers
- Follow established Next.js and XM Cloud patterns consistently

### Data Flow

- Prefer unidirectional data flow
- Validate inputs at component boundaries
- Transform data at appropriate layers
- Handle errors close to their source

---

## Development Workflow

### Local Development Setup

```bash
# Navigate to any starter
cd examples/kit-nextjs-article-starter

# Copy environment template
cp .env.remote.example .env.local

# Edit .env.local with your XM Cloud values
# Required variables:
# - SITECORE_EDGE_CONTEXT_ID
# - NEXT_PUBLIC_DEFAULT_SITE_NAME
# - SITECORE_EDITING_SECRET

# Install dependencies and start
npm install
npm run dev
```

### Version Control

- Write descriptive commit messages
- Keep commits focused and atomic
- Use branching strategies appropriate to team size
- Review code before merging to dev branch

### Documentation

- Document public APIs and component interfaces
- Include usage examples for complex functionality
- Keep documentation close to code
- Update documentation with code changes

### Code Review

- Review for logic, readability, and maintainability
- Check error handling and edge cases
- Verify tests cover new functionality
- Ensure documentation is updated

### Continuous Integration

- All tests must pass before merging
- Linting and formatting checks must pass
- Build process must complete successfully
- No breaking changes without proper migration

### Lint and Format

- Keep ESLint + Prettier passing at all times
- Follow configured style rules consistently
- Use automated formatting on save
- Address linting warnings promptly
- Maintain consistent code style across all starters

---

## Safety Rules

### Never Edit Compiled Artifacts

**Do Not Edit:**
- `node_modules/` - Installed packages
- `.next/`, `dist/`, `out/`, `build/` - Generated during build
- `.cache/`, `.sitecore/` - Cache directories (except component-map.ts)
- `package-lock.json`, `yarn.lock`, `pnpm-lock.yaml` - Lock files
- `*.js.map`, `*.css.map`, `*.d.ts.map` - Source maps

### Do Not Edit Configuration Files

**Avoid Modifying:**
- `scjssconfig.json`, `.sitecore/user.json` - Sitecore configs
- `Dockerfile`, `docker-compose*.yml` - Docker files
- `.github/workflows/` - CI/CD configs

### Do Not Edit Package Files

**Never Modify:**
- `*.itempackage`, `*.sicpackage` - Sitecore packages
- `*.tgz`, `*.tar.gz`, `*.zip` - Archive files
- `*.exe`, `*.dll`, `*.obj` - Binary files

### Do Not Edit Environment Files

**Never Commit:**
- `.env.local`, `.env.*.local` - Local environment
- `*.deploysecret.config` - Secret files
- `.sitecore/user.json` - User-specific configs

### Source Files Only

**Focus editing on:**
- Source code: `.ts`, `.tsx`, `.js`, `.jsx` files in `src/`
- Configuration: `next.config.js`, `tsconfig.json`, `package.json`
- Documentation: `README.md`, `CONTRIBUTING.md`
- Styles: `.css`, `.scss` files
- Component maps: `.sitecore/component-map.ts`

### When in Doubt

If unsure whether to edit a file:
1. Check if it's in `node_modules/` - never edit
2. Check if it's generated during build - never edit
3. Check if it contains secrets - never edit
4. Ask yourself: "Did I create this file?" - if no, be cautious

---

## Environment Configuration

### Required Environment Variables

**XM Cloud Integration:**
- `SITECORE_EDGE_CONTEXT_ID` - XM Cloud Edge context identifier
- `NEXT_PUBLIC_DEFAULT_SITE_NAME` - Default site name for the application
- `NEXT_PUBLIC_SITECORE_EDGE_CONTEXT_ID` - Public Edge context identifier
- `SITECORE_EDITING_SECRET` - Secret for editing mode authentication

**Setup Process:**
- Copy `.env.remote.example` to `.env.local` for local development
- Log into Sitecore XM Cloud Deploy Portal
- Locate your Environment and select `Developer Settings` tab
- Ensure `Preview` toggle is enabled
- Copy sample `.env` file contents from `Local Development` section
- Paste into `.env.local` file

### Deployment Configuration

**XM Cloud Deployment:**
- Uses `xmcloud.build.json` for rendering host configuration
- Each starter can be enabled/disabled via `enabled` flag
- Supports multiple rendering hosts in single repository
- Automatic editing host creation when split deployment is disabled
- Environment-specific configuration through XM Cloud Deploy Portal
