name: PR Validation for DMZ Branch

on:
  pull_request:
    branches: [dmz]

env:
  NODE_VERSION: "22.11.0"

jobs:
  pr-validation:
    name: Validate Pull Request
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write

    steps:
      - name: Checkout PR
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch all branches
        run: |
          git fetch origin main
          git fetch origin dmz

      - name: Check if PR is based on latest main
        id: base-check
        run: |
          echo "Checking if PR branch is up-to-date with main..."

          # Get the merge base between PR branch and main
          MERGE_BASE=$(git merge-base HEAD origin/main)
          MAIN_HEAD=$(git rev-parse origin/main)

          echo "Merge base: $MERGE_BASE"
          echo "Main HEAD:  $MAIN_HEAD"

          if [ "$MERGE_BASE" != "$MAIN_HEAD" ]; then
            echo "‚ùå ERROR: This PR branch is not based on the latest main branch."
            echo ""
            echo "Your branch was created from an outdated version of main."
            echo "This will cause duplicate commits to appear in your PR."
            echo ""
            echo "To fix this, rebase your branch onto the latest main:"
            echo ""
            echo "  git fetch origin main"
            echo "  git rebase origin/main"
            echo "  git push --force-with-lease"
            echo ""
            echo "base-check-passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "‚úÖ PR branch is based on the latest main branch"
          echo "base-check-passed=true" >> $GITHUB_OUTPUT

      - name: Check if PR can be squash merged cleanly
        id: merge-check
        run: |
          echo "Checking if PR can be squash merged to dmz..."

          # Get current branch
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)

          # Try to merge with dmz
          git checkout -b test-merge origin/dmz

          # Test if merge would have conflicts
          if git merge --squash --no-commit $CURRENT_BRANCH; then
            echo "‚úÖ PR can be squash merged to dmz without conflicts"
            echo "merge-check-passed=true" >> $GITHUB_OUTPUT
            git merge --abort 2>/dev/null || true
          else
            echo "‚ùå ERROR: This PR has merge conflicts with dmz"
            echo ""
            echo "Resolve conflicts by rebasing onto main first:"
            echo ""
            echo "  git fetch origin main"
            echo "  git rebase origin/main"
            echo "  git push --force-with-lease"
            echo ""
            echo "merge-check-passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Detect changed starters
        id: detect-changes
        run: |
          echo "Detecting changed starter applications..."

          # Get list of changed files
          CHANGED_FILES=$(git diff --name-only origin/dmz...HEAD)
          echo "Changed files: $CHANGED_FILES"

          # Detect which starters have changes
          CHANGED_STARTERS=""

          if echo "$CHANGED_FILES" | grep -q "^examples/kit-nextjs-skate-park/"; then
            CHANGED_STARTERS="$CHANGED_STARTERS kit-nextjs-skate-park"
          fi

          if echo "$CHANGED_FILES" | grep -q "^examples/kit-nextjs-article-starter/"; then
            CHANGED_STARTERS="$CHANGED_STARTERS kit-nextjs-article-starter"
          fi

          if echo "$CHANGED_FILES" | grep -q "^examples/kit-nextjs-location-finder/"; then
            CHANGED_STARTERS="$CHANGED_STARTERS kit-nextjs-location-finder"
          fi

          if echo "$CHANGED_FILES" | grep -q "^examples/kit-nextjs-product-listing/"; then
            CHANGED_STARTERS="$CHANGED_STARTERS kit-nextjs-product-listing"
          fi

          # If no specific starter changes detected, check for global changes
          if [ -z "$CHANGED_STARTERS" ]; then
            if echo "$CHANGED_FILES" | grep -q "^xmcloud.build.json\|^\.github/\|^README.md\|^CONTRIBUTING.md"; then
              echo "Global changes detected, validating all starters"
              CHANGED_STARTERS="kit-nextjs-skate-park kit-nextjs-article-starter kit-nextjs-location-finder kit-nextjs-product-listing"
            fi
          fi

          echo "Changed starters: $CHANGED_STARTERS"
          echo "changed-starters=$CHANGED_STARTERS" >> $GITHUB_OUTPUT

      - name: Install dependencies for changed starters
        run: |
          echo "Installing dependencies for changed starters..."

          for starter in ${{ steps.detect-changes.outputs.changed-starters }}; do
            if [ -d "examples/$starter" ]; then
              echo "Installing dependencies for $starter..."
              cd "examples/$starter"
              npm install
              cd ../..
            fi
          done

      - name: Generate Sitecore files for changed starters
        run: |
          echo "Generating Sitecore configuration files..."

          for starter in ${{ steps.detect-changes.outputs.changed-starters }}; do
            if [ -d "examples/$starter" ]; then
              echo "Generating files for $starter..."
              cd "examples/$starter"
              
              # Try to generate files with Sitecore tools, fallback to minimal files if credentials are missing
              if npm run sitecore-tools:generate-map 2>/dev/null; then
                echo "‚úÖ Sitecore files generated successfully for $starter"
              else
                echo "‚ö†Ô∏è Sitecore tools failed (likely missing credentials), creating minimal files for $starter"
                
                # Create minimal .sitecore directory and files
                mkdir -p .sitecore
                
                # Create minimal sites.json
                echo '[{"name":"basic","hostName":"*","language":"en"}]' > .sitecore/sites.json
                
                # Create minimal metadata.json
                echo '{"packages":{"@sitecore-content-sdk/core":"1.1.0","@sitecore-content-sdk/nextjs":"1.1.0"}}' > .sitecore/metadata.json
                
                # Create minimal component-map.ts
                echo 'export default new Map();' > .sitecore/component-map.ts
                
                # Create minimal import-map.ts
                echo 'export default [];' > .sitecore/import-map.ts
                
                echo "‚úÖ Minimal Sitecore files created for $starter"
              fi
              
              cd ../..
            fi
          done

      - name: Lint and format check
        run: |
          echo "Running linting and formatting checks..."

          for starter in ${{ steps.detect-changes.outputs.changed-starters }}; do
            if [ -d "examples/$starter" ]; then
              echo "Checking $starter..."
              cd "examples/$starter"
              
              # Run linting
              if npm run lint 2>/dev/null; then
                echo "‚úÖ Linting passed for $starter"
              else
                echo "‚ùå Linting failed for $starter"
                exit 1
              fi
              
              # Check formatting
              if npm run format:check 2>/dev/null; then
                echo "‚úÖ Formatting check passed for $starter"
              else
                echo "‚ùå Formatting check failed for $starter"
                echo "Run 'npm run prettier' to fix formatting issues"
                exit 1
              fi
              
              cd ../..
            fi
          done

      - name: Type checking
        run: |
          echo "Running TypeScript type checking..."

          for starter in ${{ steps.detect-changes.outputs.changed-starters }}; do
            if [ -d "examples/$starter" ]; then
              echo "Type checking $starter..."
              cd "examples/$starter"
              
              # Sitecore files already generated in previous step
              if npm run type-check 2>/dev/null; then
                echo "‚úÖ Type checking passed for $starter"
              else
                echo "‚ùå Type checking failed for $starter"
                exit 1
              fi
              
              cd ../..
            fi
          done

      - name: Build changed starters
        env:
          # Sitecore Edge API Configuration
          SITECORE_EDGE_URL: ${{ secrets.SITECORE_EDGE_URL }}
          SITECORE_EDGE_CONTEXT_ID: ${{ secrets.SITECORE_EDGE_CONTEXT_ID }}
          NEXT_PUBLIC_SITECORE_EDGE_CONTEXT_ID: ${{ secrets.NEXT_PUBLIC_SITECORE_EDGE_CONTEXT_ID }}

          # Sitecore Configuration
          NEXT_PUBLIC_DEFAULT_SITE_NAME: ${{ vars.NEXT_PUBLIC_DEFAULT_SITE_NAME || 'basic' }}
          SITECORE_EDITING_SECRET: ${{ secrets.SITECORE_EDITING_SECRET }}

          # Additional Sitecore Environment Variables
          NEXT_PUBLIC_SITECORE_EDGE_URL: ${{ secrets.SITECORE_EDGE_URL }}
          NEXT_PUBLIC_SITECORE_API_KEY: ${{ secrets.NEXT_PUBLIC_SITECORE_API_KEY }}
          NEXT_PUBLIC_SITECORE_API_HOST: ${{ secrets.NEXT_PUBLIC_SITECORE_API_HOST }}
          NEXT_PUBLIC_DEFAULT_LANGUAGE: ${{ vars.NEXT_PUBLIC_DEFAULT_LANGUAGE || 'en' }}
          NEXT_PUBLIC_PERSONALIZE_SCOPE: ${{ vars.NEXT_PUBLIC_PERSONALIZE_SCOPE }}
          PERSONALIZE_MIDDLEWARE_EDGE_TIMEOUT: ${{ vars.PERSONALIZE_MIDDLEWARE_EDGE_TIMEOUT || '1000' }}
        run: |
          echo "Building changed starters..."
          echo "Sitecore Environment Variables:"
          echo "  SITECORE_EDGE_URL: ${SITECORE_EDGE_URL:+[SET]}"
          echo "  SITECORE_EDGE_CONTEXT_ID: ${SITECORE_EDGE_CONTEXT_ID:+[SET]}"
          echo "  NEXT_PUBLIC_SITECORE_EDGE_CONTEXT_ID: ${NEXT_PUBLIC_SITECORE_EDGE_CONTEXT_ID:+[SET]}"
          echo "  NEXT_PUBLIC_DEFAULT_SITE_NAME: ${NEXT_PUBLIC_DEFAULT_SITE_NAME}"
          echo "  SITECORE_EDITING_SECRET: ${SITECORE_EDITING_SECRET:+[SET]}"

          for starter in ${{ steps.detect-changes.outputs.changed-starters }}; do
            if [ -d "examples/$starter" ]; then
              echo "Building $starter..."
              cd "examples/$starter"
              
              if npm run build; then
                echo "‚úÖ Build successful for $starter"
              else
                echo "‚ùå Build failed for $starter"
                exit 1
              fi
              
              cd ../..
            fi
          done

      - name: Run tests for changed starters
        run: |
          echo "Running tests for changed starters..."

          for starter in ${{ steps.detect-changes.outputs.changed-starters }}; do
            if [ -d "examples/$starter" ]; then
              echo "Testing $starter..."
              cd "examples/$starter"
              
              # Check if test script exists, if not fail the workflow
              if grep -q '"test"' package.json; then
                if npm test; then
                  echo "‚úÖ Tests passed for $starter"
                else
                  echo "‚ùå Tests failed for $starter"
                  exit 1
                fi
              else
                echo "‚ùå No test script found for $starter - tests are mandatory"
                exit 1
              fi
              
              cd ../..
            fi
          done

      - name: Comment PR with results
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });

              const botComment = comments.find(comment => 
                comment.user.type === 'Bot' && 
                comment.body.includes('## üîç PR Validation Results')
              );

              const status = '${{ job.status }}' === 'success' ? '‚úÖ **PASSED**' : '‚ùå **FAILED**';
              const emoji = '${{ job.status }}' === 'success' ? '‚úÖ' : '‚ùå';

              const body = `## üîç PR Validation Results

              ${emoji} **Status:** ${status}

              **Base Branch Check:** ${'${{ steps.base-check.outputs.base-check-passed }}' === 'true' ? '‚úÖ Based on latest main' : '‚ùå Not based on latest main - rebase required'}

              **Merge Check:** ${'${{ steps.merge-check.outputs.merge-check-passed }}' === 'true' ? '‚úÖ Can be squash merged' : '‚ùå Merge conflicts detected'}

              **Validated Starters:** ${{ steps.detect-changes.outputs.changed-starters }}

              **Checks Performed:**
              - ‚úÖ Linting and formatting
              - ‚úÖ TypeScript type checking
              - ‚úÖ Build verification
              - ‚úÖ Test execution

              **Next Steps:**
              ${'${{ job.status }}' === 'success' ? 
                '- ‚úÖ PR is ready for review and merge to dmz branch\n- After merge, the DMZ validation workflow will run as final gate\n- If DMZ validation passes, dmz can be manually merged to main using a merge commit' : 
                '- ‚ùå Please fix the issues above before merging\n- If not based on latest main: `git fetch origin main && git rebase origin/main && git push --force-with-lease`\n- If formatting issues: Run `npm run prettier`\n- Check the build logs for specific errors'
              }

              ---
              *This comment will be updated on each validation run*`;

              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: body
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: body
                });
              }
            } catch (error) {
              // Handle permission errors gracefully (e.g., PRs from forks)
              if (error.status === 403 || error.status === 404) {
                console.log('‚ö†Ô∏è Unable to comment on PR (may be from a fork or insufficient permissions). Validation results are still available in the workflow logs.');
                console.log('Validation Status:', '${{ job.status }}');
              } else {
                throw error;
              }
            }
